多线程通信主要是通过内存共享，内存共享主要关注的点是：可见性，有序性加上复合操作的原子性；我们可用认为
java的线程安全性问题主要关注3个点：可见性，有序性，原子性

java内存模型解决了可见性，有序性；锁解决了原子性

#### 一. 悲观锁() >>> synchronized会导致的问题
    1. 多线程竞争环境下，加锁释放锁会导致比较多的上下文切换，引起性能问题。
    2. 一个线程有锁会导致其他需要此锁的线程挂起。
    3. 如果一个优先级高的线程需要等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题。

#### 二. 乐观锁
    1. 乐观锁其实是一种概念，相对悲观锁，乐观锁就是假设数据是最新的，拿到数据操作之后更新之前
    再检查数据有没有人操作过如果没用操作过则更新数据，如果数据有变动就重试或者提示用户让用户去
    选择下一步如何去坐
###
    2.典型的乐观锁实现方式 CAS(compile and swap)
    具体实现方式不在详细描述可用参考 AtomicInteger->>> getAndIncrement()
  
  ##### 缺点
    1.ABA问题
    如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是
    实际上却变化了
    从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的
    compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，
    则以原子方式将该引用和该标志的值设置为给定的更新值
###    
    2.循环时间长开销大。
     自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会
     有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源
     ，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序
     冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。
###
    3.直能保证一个共享变量的原子操作
    当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，
    循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。
    比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference
    类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作
  
  




